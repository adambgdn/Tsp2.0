<!DOCTYPE html>
<html>
<head>
    <title>Travelling Salesman Problem - Simulated Annealing</title>
    <link rel="stylesheet" type="text/css" href="./main.css" />
    <link href='https://fonts.googleapis.com/css?family=Lato:400,bold' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" />
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
</head>
<body>
    <div>
        <div id="settings">
            <table>
                <tbody>
                    <tr>
                        <td>Cities</td>
                        <td>
                            <input type="text" id="cities" value="26" />
                        </td>
                    </tr>
                    <tr>
                        <td>Initial Temperature</td>
                        <td>
                            <input type="text" id="temperature" value="0.1" />
                        </td>
                    </tr>
                    <tr>
                        <td>Absolute Zero</td>
                        <td>
                            <input type="text" id="abszero" value=".005" />
                        </td>
                    </tr>
                    <tr>
                        <td>Cooling Rate</td>
                        <td>
                            <input type="text" id="coolrate" value="0.999" />
                        </td>
                    </tr>
                </tbody>
            </table>
            <p id="temperatureCalc">Temperature:</p>
            <p id="bestcost">Best Cost:</p>
            <div style="margin: 15px auto; width: 100px; border: 1px solid black;">
                <button id="solve">Solve</button>
            </div>
        </div>
        <canvas id="tsp-canvas" width="700" height="600">
            HTML5 Unsupported.
        </canvas>
    </div>
    <script type="text/javascript">
        var temperature = 0.1;
        var ABSOLUTE_ZERO = 5e-3;
        var COOLING_RATE = 0.999;
        var CITIES = 26;
        var current = [];
        var best = [];
        var best_cost = 0;

        var varosokA = [480, 150, 160, 240, 250, 121, 655, 180, 120, 190, 222, 333, 510, 170, 480, 180, 144, 560, 660, 400, 405, 150, 410, 20, 640, 30];
        var varosokB = [350, 120, 230, 300, 270, 190, 310, 350, 400, 150, 470, 350, 555, 480, 120, 480, 577, 102, 108, 280, 200, 100, 500, 30, 50, 300];

        $(document).ready(function () {
            $("#solve").click(function () {
                temperature = parseFloat($("#temperature").val());
                ABSOLUTE_ZERO = parseFloat($("#abszero").val());
                COOLING_RATE = parseFloat($("#coolrate").val());
                CITIES = parseInt($("#cities").val());
                init();
            });
        });

        var tsp_canvas = document.getElementById('tsp-canvas');
        var tsp_ctx = tsp_canvas.getContext("2d");

        //init();
        function randomInt(n) {
            return Math.floor(Math.random() * (n)); // 0 és n közötti random, egész szám
        }

        function deep_copy(array, to) { // tömb másolása másik tömbbe
            var i = array.length;
            while (i--) {
                to[i] = [array[i][0], array[i][1]];
            }
        }

        function getCost(route) {
            var cost = 0;
            for (var i = 0; i < CITIES - 1; i++) { // i:0-25
                cost = cost + getDistance(route[i], route[i + 1]); // const = const + deep_copy tömb[i] és [i+1] (azt követõ) tagjának a távolsága (getDistance), az összes egymást követõ város távolsága, teljes út hossza kivéve az utolsó és elsõ pont közötti távolság
            }
            cost = cost + getDistance(route[0], route[CITIES - 1]); // const = const + deep_copy tömb[0] és [25] tagjának a távolsága (getDistance), az összes út hosszához hozzáadjuk az utolsó és elsõ város közötti út hosszát
            return cost;
        }

        function getDistance(p1, p2) { // matek tétel: két pont távolsága megegyezik a pontok koordináta különbségeinek négyzete, összeadva, majd az egész gyök alatt
            del_x = p1[0] - p2[0];
            del_y = p1[1] - p2[1];
            return Math.sqrt((del_x * del_x) + (del_y * del_y));
        }

        function neighborSwap(route, i, j) {
            var neighbor = [];
            deep_copy(route, neighbor);
            while (i != j) {
                var t = neighbor[j];
                neighbor[j] = neighbor[i];
                neighbor[i] = t;

                i = (i + 1) % CITIES;
                if (i == j)
                    break;
                j = (j - 1 + CITIES) % CITIES;
            }
            return neighbor;
        }

        function acceptanceProbability(current_cost, neighbor_cost) {
            if (neighbor_cost < current_cost)
                return 1;
            return Math.exp((current_cost - neighbor_cost) / temperature);
        }

        function init() {
            // feltöltjük a current tömböt a városok x és y koordinátáival
            for (var i = 0; i < CITIES; i++) {
                current[i] = [varosokA[i], varosokB[i]];
            }
            deep_copy(current, best); // current tömböt deep copyzzuk a best (kezdetben üres) tömbbe
            best_cost = getCost(best); // a best_constra beállítjuk a deep_copy teljes úthosszát
            setInterval(solve, 10); // solve 10 egységnyi idõnként
        }

        function solve() {
            if (temperature > ABSOLUTE_ZERO) { // ha a hõmérséklet kisebb nagyobb mint a beállított minimum érték
                var current_cost = getCost(current); // a current_costra beállítjuk az eredti tömb teljes úthosszát
                var k = randomInt(CITIES); // k és l = randomInt(26) városok száma közötti (0 és 26) random, egész szám
                var l = randomInt(CITIES);
                var neighbor = neighborSwap(current, k, l); // copyzunk egy neighbor tömböt ahol már lesznek cserélve elemek (random k és l)
                var neighbor_cost = getCost(neighbor); // a neighbor tömb teljes úthossza
                if (Math.random() < acceptanceProbability(current_cost, neighbor_cost)) { // ha itt egyet kapunk vissza mert a neighbor_cost kisebb (vagyis jobb) lett, mint a current_cost, akkor teljesül az if. Ha nem egyet kapunk vissza az "acceptanceProbability" függvénynél, akkor is van esély arra, hogy belép az if-be
                    deep_copy(neighbor, current); // mivel a neighbor tömb jobb ezért ezt átmásoljuk a current tömbbe
                    current_cost = getCost(current); // frissítjük a current_cost a current tömb teljes úthosszával
                }
                if (current_cost < best_cost) { // ha a current_cost a best_cost-nál is jobb, akkor ezt másoljuk a best tömbbe és best_cost-ra ennek az úthosszát állítjuk be
                    deep_copy(current, best);
                    best_cost = current_cost;
                    paint();
                }
                temperature *= COOLING_RATE;
                document.getElementById("temperatureCalc").textContent = "Temperature: " + temperature;
                document.getElementById("bestcost").textContent = "Best Cost: " + best_cost;
            }
        }

        function paint() {
            tsp_ctx.clearRect(0, 0, tsp_canvas.width, tsp_canvas.height);
            // Cities
            for (var i = 0; i < CITIES; i++) {
                tsp_ctx.beginPath();
                tsp_ctx.arc(best[i][0], best[i][1], 4, 0, 2 * Math.PI);
                tsp_ctx.fillStyle = "#0000ff";
                tsp_ctx.strokeStyle = "#000";
                tsp_ctx.closePath();
                tsp_ctx.fill();
                tsp_ctx.lineWidth = 1;
                tsp_ctx.stroke();
            }
            // Links
            tsp_ctx.strokeStyle = "#ff0000";
            tsp_ctx.lineWidth = 2;
            tsp_ctx.moveTo(best[0][0], best[0][1]);
            for (var i = 0; i < CITIES - 1; i++) {
                tsp_ctx.lineTo(best[i + 1][0], best[i + 1][1]);
            }
            tsp_ctx.lineTo(best[0][0], best[0][1]);
            tsp_ctx.stroke();
            tsp_ctx.closePath();
        }
    </script>
</body>
</html>